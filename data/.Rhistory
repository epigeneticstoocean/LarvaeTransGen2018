library(installr)
update(R)
updateR()
updateR()
citation()
q()
library(installr)
updateR()
knitr::opts_chunk$set(echo = TRUE)
#a.	Body temperature in Celcius
## Something like BodyTempC or similar
#b.	How much aspirin is given per dose for a patient
## DosePerPatient or similar
#c.	Number of televisions per person
## TVPerson or similar
#d.	Height (including neck and extended legs) of giraffes
## GiraffeHeightNeckAndLegs or similar
#a.	15 x 17
15*17
#b.	13 cubed
13^3
#c.	The log of 14 using the natural log
log(14)
#d.	The log of 100 using the base 10
log(100, base=10)
#e.	The square root of 81
sqrt(81)
#a.In R, create a vector of these data, and name it appropriately.
PoolACEconc<-c(640, 1070, 780, 70, 160, 130, 60, 50, 2110, 70, 350, 30, 210, 90, 470, 580, 250, 310, 460, 430, 140, 1070, 130)
#b.	What is the mean ACE concentration of these 23 pools?
mean(PoolACEconc)
#c.	Urine on average has 4000 ng ACE/ ml. Therefore, to convert these measurements of ng ACE / L pool water to ml urine / L pool water we need to divide each by 4000. Make a new vector showing the concentration of urine per liter in these 23 pools. Give it a suitable name.
PoolAcemLUrineperL<- PoolACEconc/4000
#d.	What is the mean concentration of urine per liter? How did this change relative to the mean measurement of ng ACE / L ?
mean(PoolAcemLUrineperL)
#it is equal to 1/4000 of the ng ACE per L
#e.	The arithmetic mean is calculated by adding up all the numbers and dividing by how many numbers there are. Calculate the mean of these numbers using sum() and length(). Did you get the same answer as with using mean()?
sum(PoolAcemLUrineperL)/length(PoolAcemLUrineperL)
#f.	Use R to calculate the average amount of urine (in ml) in a 500,000 L pool.
mean(PoolAcemLUrineperL)*500000
#a.	Make a vector for each of these lists, and give them appropriate names.
O2Feeding<- c(71.0, 77.3, 82.6, 96.1, 106.6, 112.8, 121.2, 126.4, 127.5, 143.1)
O2NotFeeding<- c(42.2, 51.7, 59.8, 66.5, 81.9, 82.0, 81.3, 81.3, 96.0, 104.1)
#b.	Confirm (using R) that both of your vectors have the same number of individuals in them.
length(O2Feeding)
length(O2NotFeeding)
#c.	Create a vector called MetabolismDifference by calculating the difference in oxygen consumption between feeding dives and nonfeeding dives for each animal.
MetabolismDifference<- O2Feeding - O2NotFeeding
#d.	What is the average difference between feeding dives and nonfeeding dives in oxygen consumption?
mean(MetabolismDifference)
#e.	Another appropriate way to represent the relationship between these two numbers would be to take the ratio of O2 consumption for feeding dives over the O2 consumption of nonfeeding dives. Make a vector which gives this ratio for each seal.
O2ConsumpRatio<- O2Feeding/O2NotFeeding
#f.	Sometimes ratios are easier to analyze when we look at the log of the ratio. Create a vector which gives the log of the ratios from the previous step. (Use the natural log.) What is the mean of this log-ratio?
LogO2ConsumpRatio<-log(O2ConsumpRatio)
mean(LogO2ConsumpRatio)
#a.	Use read.csv() to read the data from this file into a data frame called countries.
countries<- read.csv("countries.csv")
#b.	Use summary() to get a quick description of this data set. What are the first three variables?
summary(countries)
# the first three variables are country, total_population_in_thousands_2015, and gross_national_income_per_capita_2013
#c.	Using the output of summary(), how many countries are from Africa in this data set?
summary(subset(countries, continent=="Africa"))
#54
#d.	What kinds of variables (i.e., categorical or numerical) are:
#1.	continents
#2.	cell_phone_subscriptions_per_100_people_2012
#3.	total_population_in_thousands_2015
#4.	fines_for_tobacco_advertising_2014
#(Don’t go by their variable names – look at the data in the str() results to decide.)
str(countries)
#1) character
#2) numeric
#3) numeric
#4) character
#e.	Add a new column to your countries data frame that has the difference in ecological footprint between 2012 and 2000. What is the mean of this difference? (Note: this variable will have “missing data”, which means that some of the countries do not have data in this file for one or the other of the years of ecological footprint. By default, R doesn’t calculate a mean unless all the data are present. To tell R to ignore the missing data, add an option to the mean() command that says na.rm=TRUE. We’ll learn more about this later.)
#1) character
#2) numeric
#3) numeric
#4) character
#e.	Add a new column to your countries data frame that has the difference in ecological footprint between 2012 and 2000. What is the mean of this difference? (Note: this variable will have “missing data”, which means that some of the countries do not have data in this file for one or the other of the years of ecological footprint. By default, R doesn’t calculate a mean unless all the data are present. To tell R to ignore the missing data, add an option to the mean() command that says na.rm=TRUE. We’ll learn more about this later.)
countries$FootprintDiff<- countries$ecological_footprint_2012-countries$ecological_footprint_2000
mean(countries$FootprintDiff, na.rm=T)
AfricaData<- subset(countries, continent=="Africa")
sum(AfricaData$total_population_in_thousands_2015)
knitr::opts_chunk$set(echo = TRUE)
#a.	15 x 17
15*17
#b.	13 cubed
13^3
q()
q()
install.packages("ggbiplot")
library(ggbiplot)
install.packages("ggbiplot")
library(ggbiplot)
install_github("vqv/ggbiplot")
library(knitr)
library(cowplot)
library(plyr)
library(tidyverse)
library(sciplot)
library(reshape2)
library(lme4)
library(lmerTest)
library(blme)
library(grid)
library(data.table)
library(gridExtra)
library(lattice)
library(optimx)
library(car)
library(Hmisc)
library(DescTools)
library(corrplot)
library(emmeans)
library(chron)
library(GLMMadaptive)
library(calibrate)
library(merTools)
library(bootpredictlme4)
library(visreg)
library(factoextra)
library(devtools)
library(ggfortify)
library(cluster)
library(mvnormtest)
library(multcompView)
library(sciplot)
setwd("~/R/GitHub/FLOysters/data")
#load CellProfiler data
CellPro<- read.csv("CellProfiler_Output_12-7-2020.csv") #contains data on shell polymorph areas
#load morphology data
Morph<- read.csv("MorphologyData.csv") #contains data on size classes, lenghts, etc.
PredDat<- read.csv("pred.surv.total.quads.csv")
View(PredDat)
TrapDat<- read.csv("pred.trap.totals.csv")
PredDat<- read.csv("pred.surv.total.quads.csv")
#start by aggregating data from cell profiler so there is a single entry per metadata ID
CellProComb<- ddply(CellPro, .(Metadata_ID), numcolwise(sum, na.rm=TRUE))
#get aragonite, hmg, and low mg into separate columns to add to Morph data
CellProComb$PolyType<- vapply(strsplit(CellProComb$Metadata_ID,"_"), '[', 4, FUN.VALUE = character(1))
CellProComb$PolyType<- ifelse(is.na(CellProComb$PolyType), paste("totalArea"), paste(CellProComb$PolyType))
CellProComb$PolyType<- factor(CellProComb$PolyType)
CellProComb$SiteID<- vapply(strsplit(CellProComb$Metadata_ID,"_"), '[', 1, FUN.VALUE = character(1) )
CellProComb$OystID<- vapply(strsplit(CellProComb$Metadata_ID,"_"), '[', 2, FUN.VALUE = character(1) )
CellProComb$ID<- paste(CellProComb$SiteID, CellProComb$OystID, sep="") #make full ID that matches the Morph full.id column
# subset the data by shell polymorph
Aragonite<- subset(CellProComb, PolyType=="a")
TotalArea<- subset(CellProComb, PolyType=="totalArea")
Repair<- subset(CellProComb, PolyType=="r")
HighMg<- subset(CellProComb, PolyType=="hmg")
Morph$Arag_Area<- Aragonite$AreaShape_Area[match(Morph$full.id, Aragonite$ID)]
Morph$Arag_Area<- ifelse(is.na(Morph$Arag_Area), 0, Morph$Arag_Area)
Morph$HighMg_Area<- HighMg$AreaShape_Area[match(Morph$full.id, HighMg$ID)]
Morph$HighMg_Area<- ifelse(is.na(Morph$HighMg_Area), 0, Morph$HighMg_Area)
Morph$Total_Area<- TotalArea$AreaShape_Area[match(Morph$full.id, TotalArea$ID)]
Morph$Repair_Area<- Repair$AreaShape_Area[match(Morph$full.id, Repair$ID)]
Morph$Repair_Area<- ifelse(is.na(Morph$Repair_Area), 0, Morph$Repair_Area)
Morph$Arag_PropArea<- Morph$Arag_Area/Morph$Total_Area
Morph$HighMg_PropArea<- Morph$HighMg_Area/Morph$Total_Area
Morph$LowMg_Area<- Morph$Total_Area- (Morph$Arag_Area + Morph$HighMg_Area)
Morph$LowMg_PropArea<- 1-(Morph$Arag_PropArea + Morph$HighMg_PropArea)
Morph$Repair_PropLowMg<- Morph$Repair_Area/Morph$LowMg_Area
#get transient predator values
TrapDat$TransientPredPerHr<- with(TrapDat, (no.cat+ no.blue+ no.stone)/time.col)
TrapDat<- read.csv("pred.trap.totals.csv")
#get transient predator values
TrapDat$TransientPredPerHr<- with(TrapDat, (no.cat+ no.blue+ no.stone)/soak)
#get transient predator values
TrapDat$TransientPredCPUE<- with(TrapDat, (no.cat+ no.blue+ no.stone)/soak)
TrapReefMeans<- ddply(TrapDat, .(reef.id, nerr.zone), numcolwise(mean, na.rm=TRUE))
#add trap data to the PredReefMeans
PredReefMeans$TransientPredCPUE<- TrapReefMeans$TransientPredCPUE[match(PredReefMeans$reef.id, TrapReefMeans$reef.id)]
#get site means by first getting reef means and then getting site mean
PredReefMeans<- ddply(PredDat, .(reef.id, nerr.zone), numcolwise(mean, na.rm=TRUE))
TrapReefMeans<- ddply(TrapDat, .(reef.id, nerr.zone), numcolwise(mean, na.rm=TRUE))
#add trap data to the PredReefMeans
PredReefMeans$TransientPredCPUE<- TrapReefMeans$TransientPredCPUE[match(PredReefMeans$reef.id, TrapReefMeans$reef.id)]
PredSiteMeans<- ddply(PredReefMeans, .(nerr.zone), numcolwise(mean, na.rm=TRUE))
View(PredSiteMeans)
#get total preds per square meter
PredDat$TotalPredM2<- PredDat$no.conch+ PredDat$no.mud
#get transient predator values
TrapDat$TransientPredCPUE<- with(TrapDat, (no.cat+ no.blue+ no.stone)/soak)
#get site means by first getting reef means and then getting site mean
PredReefMeans<- ddply(PredDat, .(reef.id, nerr.zone), numcolwise(mean, na.rm=TRUE))
TrapReefMeans<- ddply(TrapDat, .(reef.id, nerr.zone), numcolwise(mean, na.rm=TRUE))
#add trap data to the PredReefMeans
PredReefMeans$TransientPredCPUE<- TrapReefMeans$TransientPredCPUE[match(PredReefMeans$reef.id, TrapReefMeans$reef.id)]
PredSiteMeans<- ddply(PredReefMeans, .(nerr.zone), numcolwise(mean, na.rm=TRUE))
#get SEs
PredSiteSes<- ddply(PredDat, .(reef.id, nerr.zone), numcolwise(se, na.rm=TRUE)) %>% ddply(.(nerr.zone), numcolwise(se, na.rm=TRUE))
colnames(PredSiteSes)<- paste(colnames(PredSiteSes), "se", sep="_")
boxplot(TotalPredM2~nerr.zone, data=PredDat)
bp<- barplot(TotalPredM2~nerr.zone, data=PredSiteMeans, ylim=c(0,10))
arrows(x0=bp, x1=bp, y0=PredSiteMeans$TotalPredM2 - PredSiteSes$TotalPredM2_se, y1=PredSiteMeans$TotalPredM2 + PredSiteSes$TotalPredM2_se, angle=90, code=3)
#get SEs
PredSiteSes<- ddply(PredDat, .(reef.id, nerr.zone), numcolwise(se, na.rm=TRUE)) %>% ddply(.(nerr.zone), numcolwise(se, na.rm=TRUE))
#get SEs
PredSiteSes<- ddply(PredDat, .(reef.id, nerr.zone), numcolwise(se, na.rm=TRUE)) %>%
ddply(.(nerr.zone), numcolwise(se, na.rm=TRUE))
library(knitr)
library(cowplot)
library(plyr)
library(tidyverse)
library(sciplot)
library(reshape2)
library(lme4)
library(lmerTest)
library(blme)
library(grid)
library(data.table)
library(gridExtra)
library(lattice)
library(optimx)
library(car)
library(Hmisc)
library(DescTools)
library(corrplot)
library(emmeans)
library(chron)
library(GLMMadaptive)
library(calibrate)
library(merTools)
library(bootpredictlme4)
library(visreg)
library(factoextra)
library(devtools)
library(ggfortify)
library(cluster)
library(mvnormtest)
library(multcompView)
library(sciplot)
#get total preds per square meter
PredDat$TotalPredM2<- PredDat$no.conch+ PredDat$no.mud
#get transient predator values
TrapDat$TransientPredCPUE<- with(TrapDat, (no.cat+ no.blue+ no.stone)/soak)
#get site means by first getting reef means and then getting site mean
PredReefMeans<- ddply(PredDat, .(reef.id, nerr.zone), numcolwise(mean, na.rm=TRUE))
TrapReefMeans<- ddply(TrapDat, .(reef.id, nerr.zone), numcolwise(mean, na.rm=TRUE))
#add trap data to the PredReefMeans
PredReefMeans$TransientPredCPUE<- TrapReefMeans$TransientPredCPUE[match(PredReefMeans$reef.id, TrapReefMeans$reef.id)]
PredSiteMeans<- ddply(PredReefMeans, .(nerr.zone), numcolwise(mean, na.rm=TRUE))
#get SEs
PredSiteSes<- ddply(PredDat, .(reef.id, nerr.zone), numcolwise(se, na.rm=TRUE)) %>%
ddply(.(nerr.zone), numcolwise(se, na.rm=TRUE))
colnames(PredSiteSes)<- paste(colnames(PredSiteSes), "se", sep="_")
boxplot(TotalPredM2~nerr.zone, data=PredDat)
bp<- barplot(TotalPredM2~nerr.zone, data=PredSiteMeans, ylim=c(0,10))
arrows(x0=bp, x1=bp, y0=PredSiteMeans$TotalPredM2 - PredSiteSes$TotalPredM2_se, y1=PredSiteMeans$TotalPredM2 + PredSiteSes$TotalPredM2_se, angle=90, code=3)
#get SEs
PredSiteSes<- ddply(PredDat, .(reef.id, nerr.zone), numcolwise(se, na.rm=TRUE)) %>%
ddply(.(nerr.zone), numcolwise(se, na.rm=TRUE))
library(dplyr)
#get SEs
PredSiteSes<- ddply(PredDat, .(reef.id, nerr.zone), numcolwise(se, na.rm=TRUE)) %>%
ddply(.(nerr.zone), numcolwise(se, na.rm=TRUE))
#get SEs
PredReefSes<- ddply(PredDat, .(reef.id, nerr.zone), numcolwise(se, na.rm=TRUE))
PredSiteSes<- ddply(PredReefSes.(nerr.zone), numcolwise(se, na.rm=TRUE))
PredSiteSes<- ddply(PredReefSes, .(nerr.zone), numcolwise(se, na.rm=TRUE))
colnames(PredSiteSes)<- paste(colnames(PredSiteSes), "se", sep="_")
boxplot(TotalPredM2~nerr.zone, data=PredDat)
bp<- barplot(TotalPredM2~nerr.zone, data=PredSiteMeans, ylim=c(0,10))
arrows(x0=bp, x1=bp, y0=PredSiteMeans$TotalPredM2 - PredSiteSes$TotalPredM2_se, y1=PredSiteMeans$TotalPredM2 + PredSiteSes$TotalPredM2_se, angle=90, code=3)
bp2<- barplot(TransientPredCPUE~nerr.zone, data=PredSiteMeans)
arrows(x0=bp2, x1=bp2, y0=PredSiteMeans$TransientPredCPUE - PredSiteSes$TransientPredCPUE_se, y1=PredSiteMeans$TransientPredCPUE + PredSiteSes$TransientPredCPUE_se, angle=90, code=3)
library(knitr)
library(cowplot)
library(plyr)
library(tidyverse)
library(sciplot)
library(reshape2)
library(lme4)
library(lmerTest)
library(blme)
library(grid)
library(data.table)
library(gridExtra)
library(lattice)
library(optimx)
library(car)
library(Hmisc)
library(DescTools)
library(corrplot)
library(emmeans)
library(chron)
library(GLMMadaptive)
library(calibrate)
library(merTools)
library(bootpredictlme4)
library(visreg)
library(lubridate)
setwd("~/R/GitHub/LarvaeTransGen2018/data") #Elise's working directory
BARN<- read.csv("Barn_Botts.csv")
Logger<- read.csv("Barn_pH.csv")
#Make dates in the date format for R
BARN$Date<- ymd(BARN$Date)
Logger$DateTimeGMT<- ymd_hms(Logger$DateTimeGMT)
#get the months
BARN$Month<- month(BARN$Date)
Logger$Month<- month(Logger$DateTimeGMT)
Logger$Day<- day(Logger$DateTimeGMT) #make a simple month and day field
Logger$DayMonth<- as.factor(paste(Logger$Month, Logger$Day, sep="-"))
#subset to only include may-july and only tidal samples for bottles
BARN$SampType<- as.factor(BARN$SampType)
BARNsub<- subset(BARN, SampType=="Tidal" & Month!=10)
LoggerSub<- subset(Logger, Month==5 | Month==6| Month==7)
#round relative tide
BARNsub$RelTideRounded<- round(BARNsub$RelTide)
BottMeans<- ddply(BARNsub, .(RelTideRounded), numcolwise(mean, na.rm=TRUE))
BottSes<- ddply(BARNsub, .(RelTideRounded), numcolwise(se, na.rm=TRUE))
plot(OmegaAr~RelTideRounded, data=BottMeans, pch=19, xlab="Relative Tide Time", ylab= expression(paste( Omega[Aragonite])), ylim=c(0, 2.0))
abline(b=0, a=1)
arrows(x0=BottMeans$RelTideRounded, x1=BottMeans$RelTideRounded,y0=BottMeans$OmegaAr-BottSes$OmegaAr, y1=BottMeans$OmegaAr+BottSes$OmegaAr, angle=90, code=3, length=0.05, col="black")
plot(pCO2~RelTideRounded, data=BottMeans, pch=19, xlab="Relative Tide Time", ylab= expression(paste(pCO[2], " (ppm)")), ylim=c(0, 3000))
arrows(x0=BottMeans$RelTideRounded, x1=BottMeans$RelTideRounded,y0=BottMeans$pCO2-BottSes$pCO2, y1=BottMeans$pCO2+BottSes$pCO2, angle=90, code=3, length=0.05, col="black")
plot(CO3~RelTideRounded, data=BottMeans, pch=19, xlab="Relative Tide Time", ylab= expression(paste("[", CO[3], "] (", mu, "m)")), ylim=c(0, 125))
arrows(x0=BottMeans$RelTideRounded, x1=BottMeans$RelTideRounded,y0=BottMeans$CO3-BottSes$CO3, y1=BottMeans$CO3+BottSes$CO3, angle=90, code=3, length=0.05, col="black")
View(LoggerSub)
LoggerSub$Day
LoggerSub$YearDay<- days_in_month(LoggerSub$DateTimeGMT)
LoggerSub$YearDay
LoggerSub$YearDay<- day(LoggerSub$DateTimeGMT)
LoggerSub$YearDay
LoggerSub$DayMonth<- as.factor(LoggerSub$DayMonth, ordered=TRUE)
LogMeans<- ddply(LoggerSub, .(DayMonth), numcolwise(mean, na.rm=TRUE))
LogMeans$DayMonth<-droplevels(LogMeans)$DayMonth
LogSes<- ddply(LoggerSub, .(DayMonth), numcolwise(mean, na.rm=TRUE))
plot(pH~Month+Day, data=LogMeans, pch=19)
plot(pH~DayMonth, data=LogMeans, pch=19)
plot(pH~DayMonth, data=LogMeans, pch=19, type="p")
LoggerSub$DayMonth<- as.Date(LoggerSub$DateTimeGMT, "%m/%d")
LoggerSub$DayMonth<- as.Date(LoggerSub$DateTimeGMT, "%j")
str(LoggerSub$DateTimeGMT)
LoggerSub$DayMonth<- as.Date(LoggerSub$DateTimeGMT, "%y%m%d")
LoggerSub$DayMonth<- yday(LoggerSub$DateTimeGMT)
LogMeans<- ddply(LoggerSub, .(DayMonth), numcolwise(mean, na.rm=TRUE))
LogMeans$DayMonth<-droplevels(LogMeans)$DayMonth
LogSes<- ddply(LoggerSub, .(DayMonth), numcolwise(mean, na.rm=TRUE))
plot(pH~DayMonth, data=LogMeans, pch=19, type="p")
LoggerSub$Yearday<- yday(LoggerSub$DateTimeGMT) #get the year day of the data
# Chunk 1: setup
knitr::opts_chunk$set(echo = TRUE)
# Chunk 2: LoadLibraries
library(knitr)
library(cowplot)
library(plyr)
library(tidyverse)
library(sciplot)
library(reshape2)
library(lme4)
library(lmerTest)
library(blme)
library(grid)
library(data.table)
library(gridExtra)
library(lattice)
library(optimx)
library(car)
library(Hmisc)
library(DescTools)
library(corrplot)
library(emmeans)
library(chron)
library(GLMMadaptive)
library(calibrate)
library(merTools)
library(bootpredictlme4)
library(visreg)
library(lubridate)
# Chunk 3: Load Data
setwd("~/R/GitHub/LarvaeTransGen2018/data") #Elise's working directory
BARN<- read.csv("Barn_Botts.csv")
Logger<- read.csv("Barn_pH.csv")
# Chunk 4: Subset to only include May-July
#Make dates in the date format for R
BARN$Date<- ymd(BARN$Date)
Logger$DateTimeGMT<- ymd_hms(Logger$DateTimeGMT)
#get the months
BARN$Month<- month(BARN$Date)
Logger$Month<- month(Logger$DateTimeGMT)
Logger$Day<- day(Logger$DateTimeGMT) #make a simple month and day field
Logger$DayMonth<- as.factor(paste(Logger$Month, Logger$Day, sep="-"))
#subset to only include may-july and only tidal samples for bottles
BARN$SampType<- as.factor(BARN$SampType)
BARNsub<- subset(BARN, SampType=="Tidal" & Month!=10)
LoggerSub<- subset(Logger, Month==5 | Month==6| Month==7)
# Chunk 5: Bottle Figures
#round relative tide
BARNsub$RelTideRounded<- round(BARNsub$RelTide)
BottMeans<- ddply(BARNsub, .(RelTideRounded), numcolwise(mean, na.rm=TRUE))
BottSes<- ddply(BARNsub, .(RelTideRounded), numcolwise(se, na.rm=TRUE))
plot(OmegaAr~RelTideRounded, data=BottMeans, pch=19, xlab="Relative Tide Time", ylab= expression(paste( Omega[Aragonite])), ylim=c(0, 2.0))
abline(b=0, a=1)
arrows(x0=BottMeans$RelTideRounded, x1=BottMeans$RelTideRounded,y0=BottMeans$OmegaAr-BottSes$OmegaAr, y1=BottMeans$OmegaAr+BottSes$OmegaAr, angle=90, code=3, length=0.05, col="black")
plot(pCO2~RelTideRounded, data=BottMeans, pch=19, xlab="Relative Tide Time", ylab= expression(paste(pCO[2], " (ppm)")), ylim=c(0, 3000))
arrows(x0=BottMeans$RelTideRounded, x1=BottMeans$RelTideRounded,y0=BottMeans$pCO2-BottSes$pCO2, y1=BottMeans$pCO2+BottSes$pCO2, angle=90, code=3, length=0.05, col="black")
plot(CO3~RelTideRounded, data=BottMeans, pch=19, xlab="Relative Tide Time", ylab= expression(paste("[", CO[3], "] (", mu, "m)")), ylim=c(0, 125))
arrows(x0=BottMeans$RelTideRounded, x1=BottMeans$RelTideRounded,y0=BottMeans$CO3-BottSes$CO3, y1=BottMeans$CO3+BottSes$CO3, angle=90, code=3, length=0.05, col="black")
LoggerSub$Yearday<- yday(LoggerSub$DateTimeGMT) #get the year day of the data
LogMeans<- ddply(LoggerSub, .(Yearday), numcolwise(mean, na.rm=TRUE))
LogSes<- ddply(LoggerSub, .(Yearday), numcolwise(mean, na.rm=TRUE))
plot(pH~Yearday, data=LogMeans, pch=19, type="p")
plot(pH~Yearday, data=LogMeans, pch=19, type="p", xaxt="n")
axis(1,labels=LoggerSub$DayMonth)
Plot<- plot(pH~Yearday, data=LogMeans, pch=19, type="p", xaxt="n")
axis(1,at=Plot, labels=LoggerSub$DayMonth)
axis(1,at=LoggerSub$Yearday, labels=LoggerSub$DayMonth)
Plot<- plot(pH~Yearday, data=LogMeans, pch=19, type="p", xaxt="n", xlab="Month and Day")
axis(1,at=LoggerSub$Yearday, labels=LoggerSub$DayMonth)
axis(1,at=LogMeans$Yearday, labels=LogMeans$DayMonth)
Plot<- plot(pH~Yearday, data=LogMeans, pch=19, type="p", xaxt="n", xlab="Month and Day")
axis(1,at=LogMeans$Yearday, labels=LogMeans$DayMonth)
LoggerSub$Yearday<- yday(LoggerSub$DateTimeGMT) #get the year day of the data
LogMeans<- ddply(LoggerSub, .(Yearday), numcolwise(mean, na.rm=TRUE))
LogSes<- ddply(LoggerSub, .(Yearday), numcolwise(mean, na.rm=TRUE))
Plot<- plot(pH~Yearday, data=LogMeans, pch=19, type="p", xaxt="n", xlab="Month and Day")
axis(1,at=LogMeans$Yearday, labels=LogMeans$DayMonth)
arrows(x0=Plot, x1=Plot, y0=LogMeans)
Logger$DayMonth<- as.factor(paste(Logger$Month, Logger$Day, sep="-"))
Plot<- plot(pH~Yearday, data=LogMeans, pch=19, type="p", xaxt="n", xlab="Month and Day")
axis(1,at=LogMeans$Yearday, labels=LogMeans$DayMonth)
axis(1,at=LogMeans$Yearday, labels=LoggerSub$DayMonth)
axis(1,at=LoggerSub$Yearday, labels=LoggerSub$DayMonth)
Plot<- plot(pH~Yearday, data=LogMeans, pch=19, type="p", xaxt="n", xlab="Month and Day")
axis(1,at=LoggerSub$Yearday, labels=LoggerSub$DayMonth)
arrows(x0=Plot, x1=Plot, y0=LogMeans$pH - LogSes$pH, y1=LogMeans$pH + LogSes$pH)
str(LogMeans)
arrows(x0=LoggerSub$Yearday, x1=LoggerSub$YearDay, y0=LogMeans$pH - LogSes$pH, y1=LogMeans$pH + LogSes$pH)
arrows(x0=LoggerSub$Yearday, x1=LoggerSub$Yearday, y0=LogMeans$pH - LogSes$pH, y1=LogMeans$pH + LogSes$pH)
View(LogSes)
LogSes<- ddply(LoggerSub, .(Yearday), numcolwise(se, na.rm=TRUE))
Plot<- plot(pH~Yearday, data=LogMeans, pch=19, type="p", xaxt="n", xlab="Month and Day")
axis(1,at=LoggerSub$Yearday, labels=LoggerSub$DayMonth)
arrows(x0=LoggerSub$Yearday, x1=LoggerSub$Yearday, y0=LogMeans$pH - LogSes$pH, y1=LogMeans$pH + LogSes$pH)
arrows(x0=LoggerMeans$Yearday, x1=LoggerMeans$Yearday, y0=LogMeans$pH - LogSes$pH, y1=LogMeans$pH + LogSes$pH, code=3, angle=90)
Plot<- plot(pH~Yearday, data=LogMeans, pch=19, type="p", xaxt="n", xlab="Month and Day")
axis(1,at=LoggerSub$Yearday, labels=LoggerSub$DayMonth)
arrows(x0=LogMeans$Yearday, x1=LogMeans$Yearday, y0=LogMeans$pH - LogSes$pH, y1=LogMeans$pH + LogSes$pH, code=3, angle=90)
Plot<- plot(pH~Yearday, data=LogMeans, pch=19, type="p", xaxt="n", xlab="Month and Day", ylim=c(7.5, 8.05))
axis(1,at=LoggerSub$Yearday, labels=LoggerSub$DayMonth)
arrows(x0=LogMeans$Yearday, x1=LogMeans$Yearday, y0=LogMeans$pH - LogSes$pH, y1=LogMeans$pH + LogSes$pH, code=3, angle=90)
library(knitr)
library(cowplot)
library(plyr)
library(tidyverse)
library(sciplot)
library(reshape2)
library(lme4)
library(lmerTest)
library(blme)
library(grid)
library(data.table)
library(gridExtra)
library(lattice)
library(optimx)
library(car)
library(Hmisc)
library(corrplot)
library(emmeans)
library(GLMMadaptive)
library(calibrate)
library(merTools)
library(marelac)
library(oce)
library(lubridate)
library(broom)
library(mgcv)
library(knitr)
library(cowplot)
library(plyr)
library(tidyverse)
library(sciplot)
library(reshape2)
library(lme4)
library(lmerTest)
library(blme)
library(grid)
library(data.table)
library(gridExtra)
library(lattice)
library(optimx)
library(car)
library(Hmisc)
library(DescTools)
library(corrplot)
library(emmeans)
library(chron)
library(GLMMadaptive)
library(calibrate)
library(merTools)
library(bootpredictlme4)
library(visreg)
library(lubridate)
library(marelac)
