larvjarn<- aggregate(LarvaeDiamum~ParentTrt*JarTrt, data=LarvByJarDat, FUN=length)
# Chunk 15: LarvDiamStat
larvlen<-lmer(LarvaeDiamum~ParentTrt*JarSatCalcite_SW+ (1|FemaleID)+(1|MaleID)+(1|CrossID)+(1|JarID)+(1|JarSeatable)+(1|TrtTankID)+(1|MaleTrtTankID), data=LarvaeDat)
steppedlarvlen<-step(larvlen)
print(steppedlarvlen)
#final model chosen by the lme4 step function: y~ParentTrt*JarSatCalcite_SW +(1|FemaleID)+(1|MaleID)+(1|JarID)+ (1|JarSeatable)
larvlenfin<- lmer(LarvaeDiamum~ParentTrt*JarSatCalcite_SW+ (1|FemaleID)+(1|MaleID)+(1|JarID)+ (1|JarSeatable), data=LarvaeDat)
#check the final model to see that it meets assumptions
plot(larvlenfin) #seems to meet assumption of linearity and homoscedasticity
qqnorm(resid(larvlenfin))
qqline(resid(larvlenfin)) #has relatively long tails, I think this should be acceptable
acf(resid(larvlenfin)) #this looks good
summary(larvlenfin)
# Chunk 16: LarvGrowthStat
larvgrow<-lmer(GrowthPerDay~ParentTrt*JarSatCalcite_SW+(1|MaleID)+(1|CrossID)+(1|JarID) +(1|JarSeatable)+(1|TrtTankID)+(1|MaleTrtTankID), data=LarvaeDat)
steppedlarvgrow<- step(larvgrow)
print(steppedlarvgrow)
#final model chosen by the lme4 step function: y~SatCalcite_ATDIC*JarTrt+ (1|CrossID)+ (1|JarID) + (1|JarSeatable)
larvgrowfin<- lmer(GrowthPerDay~ParentTrt*JarSatCalcite_SW+(1|CrossID)+ (1|JarID) + (1|JarSeatable), data=LarvaeDat)
#check the final model to see that it meets assumptions
plot(larvgrowfin) #seems to meet assumption of linearity and homoscedasticity
qqnorm(resid(larvgrowfin))
qqline(resid(larvgrowfin)) #has relatively long tails, based on scale I think it reasonably meets assumption of normality.
acf(resid(larvgrowfin))
summary(larvgrowfin)
ggplot(LarvaeDat, aes(x=GrowthPerDay,color=JarTrt))+
geom_histogram(alpha=0.5, position="identity")+
facet_grid(ParentTrt~.)
ProblemCross<- subset(LarvaeDat, CrossID=="CF02_CM02_B1_QG")
ggplot(ProblemCross, aes(y=GrowthPerDay,x=JarID, color=JarTrt))+
geom_boxplot(alpha=0.5, position="identity")
# Chunk 17: SurfaceAreaStat
larvareat<-lmer(sqrt(LarvaeAreaum2)~ParentTrt*JarSatCalcite_SW+ (1|FemaleID)+(1|MaleID)+(1|CrossID)+(1|JarSeatable)+(1|JarID)+(1|TrtTankID)+(1|MaleTrtTankID) , data=LarvaeDat)
steppedlarvareat<-step(larvareat)
print(steppedlarvareat)
#final model chosen by the lme4 step function: y~SatCalcite_ATDIC*JarTrt+(1|FemaleID)+(1|MaleID)+(1|JarID)+(1|JarSeatable)
larvareafint<- lmer(sqrt(LarvaeAreaum2)~ParentTrt*JarSatCalcite_SW+(1|FemaleID)+(1|MaleID)+(1|JarID)+(1|JarSeatable), data=LarvaeDat)
plot(larvareafint) #seems to meet assumption of linearity and homoscedasticity
qqnorm(resid(larvareafint))
qqline(resid(larvareafint)) #this seems to have improved it
acf(resid(larvareafint)) #this looks fine to me.
summary(larvareafint)
# Chunk 18: LarvAxesStat
larvrat<-lmer(MajMinRat~ParentTrt*JarSatCalcite_SW+ (1|FemaleID)+(1|MaleID)+(1|JarSeatable)+(1|JarID)+(1|AccTankID) +(1|CrossID)++(1|TrtTankID)+(1|MaleTrtTankID), data=LarvaeDat)
larvratstep<- step(larvrat)
print(larvratstep)
larvratfin<- lmer(MajMinRat~ParentTrt*JarSatCalcite_SW +(1|FemaleID)+(1|JarID), data=LarvaeDat)
#check the model to see that it meets assumptions
plot(larvratfin) #seems to meet assumption of linearity and homoscedasticity
qqnorm(resid(larvratfin))
qqline(resid(larvratfin)) #has relatively long tails, doesn't seem to meet assumption of normality. try a transformation
acf(resid(larvratfin)) #this looks fine.
summary(larvratfin)
# Chunk 19: PerimeterToLengthStat
PerDiRat<- lmer((LarvaePerimeterum/LarvaeDiamum)~ParentTrt*JarSatCalcite_SW+(1|FemaleID)+(1|MaleID)+(1|JarSeatable)+(1|JarID) +(1|CrossID)+(1|TrtTankID)+(1|MaleTrtTankID), data=LarvaeDat)
PerDiStep<- step(PerDiRat)
print(PerDiStep)
#final model chosen PerimDiamRat ~ SatCalcite_ATDIC * JarTrt + (1 | FemaleID) + (1 | JarID)
PerDiRatFin<- lmer((LarvaePerimeterum/LarvaeDiamum) ~ ParentTrt*JarSatCalcite_SW + (1 | FemaleID) + (1 | JarID)+(1|JarSeatable), data=LarvaeDat)
#check the model to see that it meets assumptions
plot(PerDiRatFin) #seems to meet assumption of linearity and homoscedasticity
qqnorm(resid(PerDiRatFin))
qqline(resid(PerDiRatFin)) #this looks fine
acf(resid(PerDiRatFin))
summary(PerDiRatFin)
# Chunk 20: EccentricityStat
larveccen<-lmer(LarvaeEccentricity^3~ParentTrt*JarSatCalcite_SW+ (1|FemaleID)+(1|MaleID)+(1|CrossID)+(1|JarSeatable)+(1|JarID)+(1|TrtTankID)+(1|MaleTrtTankID), data=LarvaeDat)
steppedlarveccen<- step(larveccen)
print(steppedlarveccen)
#final model
larveccenfin<- lmer(LarvaeEccentricity^3~ParentTrt*JarSatCalcite_SW+ (1|FemaleID)+(1|JarID), data=LarvaeDat)
#check the model to see that it meets assumptions
plot(larveccenfin) #seems to meet assumption of linearity and homoscedasticity
qqnorm(resid(larveccenfin))
qqline(resid(larveccenfin)) #has relatively long tails, doesn't meet assumption of normality.
acf(resid(larveccenfin))
summary(larveccenfin)
# Chunk 21: PerimeterStat
larvperim<-lmer(LarvaePerimeterum~ParentTrt*JarSatCalcite_SW+ (1|FemaleID)+(1|MaleID)+(1|CrossID)+(1|JarSeatable)+(1|JarID)+(1|TrtTankID)+(1|MaleTrtTankID), data=LarvaeDat)
steppedlarvperim<- step(larvperim)
print(steppedlarvperim)
#final model chosen by the step function: LarvaePerimeterum~SatCalcite_ATDIC*JarTrt+ (1|FemaleID)+(1|MaleID)+(1|JarSeatable)+(1|JarID)
larvperimfin<- lmer(LarvaePerimeterum~ParentTrt*JarSatCalcite_SW+ (1|FemaleID)+(1|MaleID)+(1|JarSeatable)+(1|JarID), data=LarvaeDat)
#check the model to see that it meets assumptions
plot(larvperimfin) #seems to meet assumption of linearity and homoscedasticity
qqnorm(resid(larvperimfin))
qqline(resid(larvperimfin)) #has relatively long tails, doesn't meet assumption of normality.
acf(resid(larvperimfin)) #this looks fine to me.
summary(larvperimfin)
# Chunk 22: SurvivalStat
surv1<- lmer(RatSurv~ParentTrt+ (1|FemaleID)+(1|MaleID)+(1|TrtTankID)+(1|MaleTrtTankID), data=SurvWideDat)
plot(surv1)
qqnorm(resid(surv1))
qqline(resid(surv1))
acf(resid(surv1))
survstepFE<- step(surv1)
print(survstepFE)
survfin<- lmer(RatSurv~ (1|FemaleID), data=SurvWideDat)#final model chosen by step function: RatSurv~ (1|FemaleID)
plot(survfin)
qqnorm(resid(survfin))
qqline(resid(survfin))
acf(resid(survfin))
summary(survfin)
#try to see if this is significantly different for exposed vs control
SurvOA<- subset(SurvWideDat, ParentTrt=="2600")
SurvCon<- subset(SurvWideDat, ParentTrt=="400")
t.test(SurvOA$RatSurv, mu = 1, alternative = "two.sided")
t.test(SurvCon$RatSurv, mu = 1, alternative = "two.sided")
# Chunk 23: FinalModelsWithSameRandomEffects
summary(larvgrowfin)
summary(larvareafint)
summary(larvlenfin)
summary(larvperimfin)
# Chunk 24: LegendEnhanced functioin
legend.enhanced <- function (x, y = NULL, legend, fill = NULL, col = par("col"),
border = "black", lty, lwd, pch, angle = 45, density = NULL,
bty = "o", bg = par("bg"), box.lwd = par("lwd"), box.lty = par("lty"),
box.col = par("fg"), pt.bg = NA, cex = 1, pt.cex = cex,
pt.lwd = lwd, xjust = 0, yjust = 1, x.intersp = 1, y.intersp = 1,
adj = c(0, 0.5), text.width = NULL, text.col = par("col"),
text.font = NULL, merge = do.lines && has.pch, trace = FALSE,
plot = TRUE, ncol = 1, horiz = FALSE, title = NULL, inset = 0,
xpd, title.col = text.col, title.adj = c(0.5,0), seg.len = 2)
{
if (missing(legend) && !missing(y) && (is.character(y) ||
is.expression(y))) {
legend <- y
y <- NULL
}
mfill <- !missing(fill) || !missing(density)
if (!missing(xpd)) {
op <- par("xpd")
on.exit(par(xpd = op))
par(xpd = xpd)
}
title <- as.graphicsAnnot(title)
if (length(title) > 1)
stop("invalid 'title'")
legend <- as.graphicsAnnot(legend)
n.leg <- if (is.call(legend))
1
else length(legend)
if (n.leg == 0)
stop("'legend' is of length 0")
auto <- if (is.character(x))
match.arg(x, c("bottomright", "bottom", "bottomleft",
"left", "topleft", "top", "topright", "right", "center"))
else NA
if (is.na(auto)) {
xy <- xy.coords(x, y)
x <- xy$x
y <- xy$y
nx <- length(x)
if (nx < 1 || nx > 2)
stop("invalid coordinate lengths")
}
else nx <- 0
xlog <- par("xlog")
ylog <- par("ylog")
rect2 <- function(left, top, dx, dy, density = NULL, angle,
...) {
r <- left + dx
if (xlog) {
left <- 10^left
r <- 10^r
}
b <- top - dy
if (ylog) {
top <- 10^top
b <- 10^b
}
rect(left, top, r, b, angle = angle, density = density,
...)
}
segments2 <- function(x1, y1, dx, dy, ...) {
x2 <- x1 + dx
if (xlog) {
x1 <- 10^x1
x2 <- 10^x2
}
y2 <- y1 + dy
if (ylog) {
y1 <- 10^y1
y2 <- 10^y2
}
segments(x1, y1, x2, y2, ...)
}
points2 <- function(x, y, ...) {
if (xlog)
x <- 10^x
if (ylog)
y <- 10^y
points(x, y, ...)
}
text2 <- function(x, y, ...) {
if (xlog)
x <- 10^x
if (ylog)
y <- 10^y
text(x, y, ...)
}
if (trace)
catn <- function(...) do.call("cat", c(lapply(list(...),
formatC), list("\n")))
cin <- par("cin")
Cex <- cex * par("cex")
if (is.null(text.width))
text.width <- max(abs(strwidth(legend, units = "user",
cex = cex, font = text.font)))
else if (!is.numeric(text.width) || text.width < 0)
stop("'text.width' must be numeric, >= 0")
xc <- Cex * xinch(cin[1L], warn.log = FALSE)
yc <- Cex * yinch(cin[2L], warn.log = FALSE)
if (xc < 0)
text.width <- -text.width
xchar <- xc
xextra <- 0
yextra <- yc * (y.intersp - 1)
ymax <- yc * max(1, strheight(legend, units = "user", cex = cex)/yc)
ychar <- yextra + ymax
if (trace)
catn("  xchar=", xchar, "; (yextra,ychar)=", c(yextra,
ychar))
if (mfill) {
xbox <- xc * 0.8
ybox <- yc * 0.5
dx.fill <- xbox
}
do.lines <- (!missing(lty) && (is.character(lty) || any(lty >
0))) || !missing(lwd)
n.legpercol <- if (horiz) {
if (ncol != 1)
warning(gettextf("horizontal specification overrides: Number of columns := %d",
n.leg), domain = NA)
ncol <- n.leg
1
}
else ceiling(n.leg/ncol)
has.pch <- !missing(pch) && length(pch) > 0
if (do.lines) {
x.off <- if (merge)
-0.7
else 0
}
else if (merge)
warning("'merge = TRUE' has no effect when no line segments are drawn")
if (has.pch) {
if (is.character(pch) && !is.na(pch[1L]) && nchar(pch[1L],
type = "c") > 1) {
if (length(pch) > 1)
warning("not using pch[2..] since pch[1L] has multiple chars")
np <- nchar(pch[1L], type = "c")
pch <- substr(rep.int(pch[1L], np), 1L:np, 1L:np)
}
if (!is.character(pch))
pch <- as.integer(pch)
}
if (is.na(auto)) {
if (xlog)
x <- log10(x)
if (ylog)
y <- log10(y)
}
if (nx == 2) {
x <- sort(x)
y <- sort(y)
left <- x[1L]
top <- y[2L]
w <- diff(x)
h <- diff(y)
w0 <- w/ncol
x <- mean(x)
y <- mean(y)
if (missing(xjust))
xjust <- 0.5
if (missing(yjust))
yjust <- 0.5
}
else {
h <- (n.legpercol + (!is.null(title))) * ychar + yc
w0 <- text.width + (x.intersp + 1) * xchar
if (mfill)
w0 <- w0 + dx.fill
if (do.lines)
w0 <- w0 + (seg.len + x.off) * xchar
w <- ncol * w0 + 0.5 * xchar
if (!is.null(title) && (abs(tw <- strwidth(title, units = "user",
cex = cex) + 0.5 * xchar)) > abs(w)) {
xextra <- (tw - w)/2
w <- tw
}
if (is.na(auto)) {
left <- x - xjust * w
top <- y + (1 - yjust) * h
}
else {
usr <- par("usr")
inset <- rep_len(inset, 2)
insetx <- inset[1L] * (usr[2L] - usr[1L])
left <- switch(auto, bottomright = , topright = ,
right = usr[2L] - w - insetx, bottomleft = ,
left = , topleft = usr[1L] + insetx, bottom = ,
top = , center = (usr[1L] + usr[2L] - w)/2)
insety <- inset[2L] * (usr[4L] - usr[3L])
top <- switch(auto, bottomright = , bottom = , bottomleft = usr[3L] +
h + insety, topleft = , top = , topright = usr[4L] -
insety, left = , right = , center = (usr[3L] +
usr[4L] + h)/2)
}
}
if (plot && bty != "n") {
if (trace)
catn("  rect2(", left, ",", top, ", w=", w, ", h=",
h, ", ...)", sep = "")
rect2(left, top, dx = w, dy = h, col = bg, density = NULL,
lwd = box.lwd, lty = box.lty, border = box.col)
}
xt <- left + xchar + xextra + (w0 * rep.int(0:(ncol - 1),
rep.int(n.legpercol, ncol)))[1L:n.leg]
yt <- top - 0.5 * yextra - ymax - (rep.int(1L:n.legpercol,
ncol)[1L:n.leg] - 1 + (!is.null(title))) * ychar
if (mfill) {
if (plot) {
if (!is.null(fill))
fill <- rep_len(fill, n.leg)
rect2(left = xt, top = yt + ybox/2, dx = xbox, dy = ybox,
col = fill, density = density, angle = angle,
border = border)
}
xt <- xt + dx.fill
}
if (plot && (has.pch || do.lines))
col <- rep_len(col, n.leg)
if (missing(lwd) || is.null(lwd))
lwd <- par("lwd")
if (do.lines) {
if (missing(lty) || is.null(lty))
lty <- 1
lty <- rep_len(lty, n.leg)
lwd <- rep_len(lwd, n.leg)
ok.l <- !is.na(lty) & (is.character(lty) | lty > 0) &
!is.na(lwd)
if (trace)
catn("  segments2(", xt[ok.l] + x.off * xchar, ",",
yt[ok.l], ", dx=", seg.len * xchar, ", dy=0, ...)")
if (plot)
segments2(xt[ok.l] + x.off * xchar, yt[ok.l], dx = seg.len *
xchar, dy = 0, lty = lty[ok.l], lwd = lwd[ok.l],
col = col[ok.l])
xt <- xt + (seg.len + x.off) * xchar
}
if (has.pch) {
pch <- rep_len(pch, n.leg)
pt.bg <- rep_len(pt.bg, n.leg)
pt.cex <- rep_len(pt.cex, n.leg)
pt.lwd <- rep_len(pt.lwd, n.leg)
ok <- !is.na(pch)
if (!is.character(pch)) {
ok <- ok & (pch >= 0 | pch <= -32)
}
else {
ok <- ok & nzchar(pch)
}
x1 <- (if (merge && do.lines)
xt - (seg.len/2) * xchar
else xt)[ok]
y1 <- yt[ok]
if (trace)
catn("  points2(", x1, ",", y1, ", pch=", pch[ok],
", ...)")
if (plot)
points2(x1, y1, pch = pch[ok], col = col[ok], cex = pt.cex[ok],
bg = pt.bg[ok], lwd = pt.lwd[ok])
}
xt <- xt + x.intersp * xchar
if (plot) {
if (is.na(title.adj[2])) { title.adj[2] <- 0}
if (!is.null(title))
text2(left + w * title.adj[1], top - ymax, labels = title,
adj = c(title.adj[1], title.adj[2]), cex = cex, col = title.col)
text2(xt, yt, labels = legend, adj = adj, cex = cex,
col = text.col, font = text.font)
}
invisible(list(rect = list(w = w, h = h, left = left, top = top),
text = list(x = xt, y = yt)))
}
# Chunk 25: MultipanelFigure
par(mfcol=c(1,1), mar=c(4,4.3, .75,1))
p1=visreg(larvgrowfin, "JarSatCalcite_SW", by="ParentTrt", overlay=TRUE, ylab=expression(paste("Growth (", mu, "m/day)")), xlab=expression(paste("Larvae Treatment ", Omega[Calcite])), legend=FALSE)
par(mfcol=c(2,2))
p2<-visreg(larvlenfin, "JarSatCalcite_SW", by="ParentTrt", overlay=TRUE, ylab=expression(paste("Length (", mu, "m)")), xlab="", legend=FALSE)
p3<-visreg(larvareafint, "JarSatCalcite_SW", by="ParentTrt", overlay=TRUE, ylab=expression(sqrt(paste("Area (", mu, m^2,")"))), xlab=expression(paste("Larvae Treatment ", Omega[Calcite])), legend=FALSE)
p4<-visreg(larvperimfin, "JarSatCalcite_SW", by="ParentTrt", overlay=TRUE, ylab=expression(paste("Perimeter (", mu, "m)")), xlab="", legend=FALSE)
p5<-visreg(PerDiRatFin, "JarSatCalcite_SW", by="ParentTrt", overlay=TRUE, ylab="Perimeter :Length", xlab=expression(paste("Larvae Treatment ", Omega[Calcite])), legend=FALSE)
# Chunk 26: SurvivalVisualization
ggplot(data = meansurv, aes(x = JarSatCalcite_SW, y = LarvaeSurvived, group=ParentTrt, fill=ParentTrt, color=ParentTrt)) +
geom_point(aes(colour=ParentTrt), size=2)+
geom_ribbon( aes(ymin = survlwrBT, ymax = survuprBT, fill = ParentTrt, color = NULL), alpha = .15) +
geom_line( aes(y = survfitBT, color=ParentTrt), size = 1)+
geom_errorbar(aes(ymin= LarvaeSurvived-sesurv$LarvaeSurvived, ymax=LarvaeSurvived+sesurv$LarvaeSurvived),width=0)+
geom_errorbarh(aes(xmin= JarSatCalcite_SW-sesurv$JarSatCalcite_SW, xmax=JarSatCalcite_SW+sesurv$JarSatCalcite_SW),height=0, position=position_dodge(0))+
labs(x = "Larvae Jar Saturation State (Calcite)", y = "Larvae Survived") +
scale_color_manual(values = c("red2","skyblue2"), name="Parent Treatment", labels= c("OA Exposed", "Control"))+
scale_fill_manual(values = c("red2","skyblue2"), name="Parent Treatment", labels= c("OA Exposed", "Control"))+
theme_classic()
ggplot(data = meansurvsub, aes(x = JarSatCalcite_SW, y = LarvaeSurvived)) +
geom_point(size=2)+
geom_ribbon( aes(ymin = survlwrBT, ymax = survuprBT, color = NULL), alpha = .15) +
geom_line( aes(y = survfitBT), size = 1)+
ylim(c(200,1400))+
geom_errorbar(aes(ymin= LarvaeSurvived-sesurvsub$LarvaeSurvived, ymax=LarvaeSurvived+sesurvsub$LarvaeSurvived),width=0)+
geom_errorbarh(aes(xmin= JarSatCalcite_SW-sesurvsub$JarSatCalcite_SW, xmax=JarSatCalcite_SW+sesurvsub$JarSatCalcite_SW),height=0, position=position_dodge(0))+
labs(x =expression(paste(Omega[Calcite])),
y = expression(paste("Number of Surviving Larvae")))+
theme_classic()
#this figure doesn't account for parent treatment because it wasn't significant
boxplot(RatSurv~as.factor(ParentTrt), data=SurvWideDat)
boxplot(SurvChange~as.factor(ParentTrt), data= SurvWideDat)
#make reaction norms for survival color will be parent treatment. X will be jar treatment. Each cross will be its own line
ggplot(SurvDat,aes(x=JarTrt, y=LarvaeSurvived, color = ParentTrt, group= CrossID)) +
geom_point(aes(color=ParentTrt))+
geom_line(aes(color=ParentTrt, group=CrossID))+
geom_errorbar(aes(ymin= LarvaeSurvived-SELarvaeSurvived, ymax=LarvaeSurvived+SELarvaeSurvived),width=0.05, position=position_dodge(0))+
labs(x = "Larvae Treatment", y = "Number of Larvae Survived") +
scale_color_manual(values = c("skyblue2", "red2")) +
theme_classic()
ggplot(SurvWideDat,
aes(y = SurvChange, x = ParentTrt)) +
geom_point() +
ggtitle("Larvae survival by parent treatment")+
ylab("Proportion change in the number of larvae that survived")+
theme_classic()
meansurv2<- ddply(SurvWideDat, .(ParentTrt), numcolwise(mean, na.rm=T))
sesurv<- ddply(SurvWideDat, .(ParentTrt), numcolwise(se, na.rm=T))
#make a shorter name for the CrossIDs in SurvWideDat
SurvWideDat$Cross<- substr(SurvWideDat$CrossID, 1, 9)
ggplot(data = SurvWideDat, aes(x = Cross, y = RatSurv, fill=ParentTrt)) +
geom_bar(stat="identity", position="dodge")+
labs(x = "Cross ID", y = "Proportion of Larvae that Survived") +
scale_fill_manual(name = "Parent Treatment", labels = c("Control", "OA Exposed"), values = c("skyblue2", "red2")) +
theme(axis.text.x=element_text(angle=90))
ggplot(data = meansurv2, aes(x = ParentTrt, y = RatSurv)) +
geom_bar(stat="identity", position="dodge")+
labs(x = "Parent Treatment", y = "Proportion of Larvae that Survived")+
geom_errorbar(aes(ymin= RatSurv-sesurv$RatSurv, ymax=RatSurv+sesurv$RatSurv),width=0.2, position=position_dodge(.9))+
theme_classic()
# Chunk 27: GetDescriptiveStats
#get means for the data
meanJarTrt<- ddply(LarvaeDat, .(JarTrt, ParentTrt), numcolwise(mean, na.rm=T))
seJarTrt<- ddply(LarvaeDat, .(JarTrt, ParentTrt), numcolwise(se, na.rm=T))
mgpd<- subset(meanJarTrt, select= c(JarTrt, ParentTrt, GrowthPerDay, LarvaeDiamum, LarvaeAreaum2, LarvaePerimeterum, PerimDiamRat))
(mgpd$GrowthPerDay[3]-mgpd$GrowthPerDay[4])/mgpd$GrowthPerDay[4]
(mgpd$GrowthPerDay[1]-mgpd$GrowthPerDay[2])/mgpd$GrowthPerDay[2]
(mgpd$LarvaeDiamum[3]-mgpd$LarvaeDiamum[4])/mgpd$LarvaeDiamum[4]
(mgpd$LarvaeDiamum[1]-mgpd$LarvaeDiamum[2])/mgpd$LarvaeDiamum[2]
mean(mgpd$LarvaeDiamum[1:2])/mean(mgpd$LarvaeDiamum[3:4])
(mgpd$LarvaeAreaum2[3]-mgpd$LarvaeAreaum2[4])/mgpd$LarvaeAreaum2[4]
(mgpd$LarvaeAreaum2[1]-mgpd$LarvaeAreaum2[2])/mgpd$LarvaeAreaum2[2]
mean(mgpd$LarvaeAreaum2[1:2])/mean(mgpd$LarvaeAreaum2[3:4])
(mgpd$LarvaePerimeterum[3]-mgpd$LarvaePerimeterum[4])/mgpd$LarvaePerimeterum[4]
(mgpd$LarvaePerimeterum[1]-mgpd$LarvaePerimeterum[2])/mgpd$LarvaePerimeterum[2]
mean(mgpd$LarvaePerimeterum[1:2])/mean(mgpd$LarvaePerimeterum[3:4])
mean(SurvWideDat$RatSurv, na.rm=TRUE)
# Chunk 28: ExportFigures
plots.dir.path<- list.files(tempdir(), pattern="rs-graphics", full.names= TRUE)
plots.png.paths<- list.files(plots.dir.path, pattern=".png", full.names=TRUE)
file.copy(from=plots.png.paths, to="../results")
# Chunk 29: t-tests
#get Bonferoni adjusted p-crit:
0.05/10
Lexp<- subset(LarvaeDat, JarTrt=="Exposed")
Lcon<- subset(LarvaeDat, JarTrt=="Control")
t.test(GrowthPerDay~ParentTrt, data=Lexp)
t.test(GrowthPerDay~ParentTrt, data=Lcon)
t.test(LarvaeDiamum~ParentTrt, data=Lexp)
t.test(LarvaeDiamum~ParentTrt, data=Lcon)#not significantly different for control larvae
t.test(LarvaeAreaum2~ParentTrt, data=Lexp)
t.test(LarvaeAreaum2~ParentTrt, data=Lcon) #not signficantly different for control larvae
t.test(LarvaePerimeterum~ParentTrt, data=Lexp)
t.test(LarvaePerimeterum~ParentTrt, data=Lcon) #not significantly different for control larvae
t.test(PerimLenRat~ParentTrt, data=Lexp)
t.test(PerimLenRat~ParentTrt, data=Lcon)#not significantly different for control larvae
(mgpd$GrowthPerDay[3]-mgpd$GrowthPerDay[4])/mgpd$GrowthPerDay[4]
mgpd<- subset(meanJarTrt, select= c(JarTrt, ParentTrt, GrowthPerDay, LarvaeDiamum, LarvaeAreaum2, LarvaePerimeterum, PerimDiamRat))
mgpd<- subset(meanJarTrt, select= c(JarTrt, ParentTrt, GrowthPerDay, LarvaeDiamum, LarvaeAreaum2, LarvaePerimeterum))
(mgpd$GrowthPerDay[3]-mgpd$GrowthPerDay[4])/mgpd$GrowthPerDay[4]
(mgpd$GrowthPerDay[1]-mgpd$GrowthPerDay[2])/mgpd$GrowthPerDay[2]
(mgpd$LarvaeDiamum[3]-mgpd$LarvaeDiamum[4])/mgpd$LarvaeDiamum[4]
(mgpd$LarvaeDiamum[1]-mgpd$LarvaeDiamum[2])/mgpd$LarvaeDiamum[2]
mean(mgpd$LarvaeDiamum[1:2])/mean(mgpd$LarvaeDiamum[3:4])
(mgpd$LarvaeAreaum2[3]-mgpd$LarvaeAreaum2[4])/mgpd$LarvaeAreaum2[4]
View(mgpd)
(mgpd$LarvaeAreaum2[3]-mgpd$LarvaeAreaum2[4])/mgpd$LarvaeAreaum2[4]
(mgpd$LarvaeDiamum[3]-mgpd$LarvaeDiamum[4])/mgpd$LarvaeDiamum[4]
(mgpd$LarvaePerimeterum[3]-mgpd$LarvaePerimeterum[4])/mgpd$LarvaePerimeterum[4]
(mgpd$GrowthPerDay[3]-mgpd$GrowthPerDay[4])/mgpd$GrowthPerDay[4]
(mgpd$GrowthPerDay[1]-mgpd$GrowthPerDay[2])/mgpd$GrowthPerDay[2]
View(mgpd)
mgpd$GrowthPerDay[1]/mgpd$GrowthPerDay[2]
mgpd$GrowthPerDay[3]/mgpd$GrowthPerDay[4]
(mgpd$LarvaeDiamum[3]-mgpd$LarvaeDiamum[4])/mgpd$LarvaeDiamum[4]
(mgpd$LarvaeDiamum[1]-mgpd$LarvaeDiamum[2])/mgpd$LarvaeDiamum[2]
mean(mgpd$LarvaePerimeterum[1:2])/mean(mgpd$LarvaePerimeterum[3:4])
Lexp<- subset(LarvaeDat, JarTrt=="Exposed")
Lcon<- subset(LarvaeDat, JarTrt=="Control")
t.test(GrowthPerDay~ParentTrt, data=Lexp)
t.test(GrowthPerDay~ParentTrt, data=Lcon)
t.test(LarvaeDiamum~ParentTrt, data=Lexp)
t.test(LarvaeDiamum~ParentTrt, data=Lcon)#not significantly different for control larvae
t.test(LarvaeAreaum2~ParentTrt, data=Lexp)
t.test(LarvaeAreaum2~ParentTrt, data=Lcon) #not signficantly different for control larvae
t.test(LarvaePerimeterum~ParentTrt, data=Lexp)
